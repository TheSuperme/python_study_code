import socket


"""
    尝试将字节数组解码为字符串。
        该函数首先尝试使用 'UTF-8' 编码解码字节数组。
        如果 'UTF-8' 解码失败（例如，因为字节数组不是有效的 UTF-8 编码），
        它会回退到使用 'GBK' 编码进行解码。
    Args:
        bytes_arr (bytes): 需要解码的字节数组。
    Returns:
        str: 解码后的字符串。
"""
def decode_data(bytes_arr:bytes):
    try:
        msg = bytes_arr.decode('UTF-8')
    except:
        msg = bytes_arr.decode('GBK')

    return msg


#-----------------注：使用时需要导入头文件      import socket -------------
"""
    获取本机所以IP
     return 返回值： IP 列表        将包含所有IP地址的、排好序的列表作为函数的最终结果返回。
1. 整体思路是什么？

一台电脑可以有多个“网络身份”，也就是多个IP地址。比如：

一个回环地址 (127.0.0.1)：这是电脑“自己跟自己对话”时用的地址，永远都指向本机。

一个或多个局域网地址：如果你连接了WiFi，会有一个IP地址（例如 192.168.1.10）。如果你同时还插了网线，可能又会有一个不同的地址。如果你开了虚拟机，虚拟机可能也会创建一个虚拟网卡，它也有自己的IP。

公网地址：这个是你的路由器在整个互联网上的地址，通常我们通过代码直接获取的是局域网IP，而不是这个。

这个函数的思路就是：

先问操作系统：“嗨，我这台电脑叫什么名字？”

再拿着这个名字去问操作系统：“那么，叫这个名字的电脑，它都绑定了哪些IP地址？”

把所有找到的IP地址，加上那个永远存在的 127.0.0.1，整理成一个列表返回。     
"""
def get_local_ip():
    # 第1步：创建一个列表，并预置一个IP
    local_ips = ["127.0.0.1"]
    # 第2步：获取并遍历所有其他IP地址
    for ip in socket.gethostbyname_ex(socket.gethostname())[2]:             #socket.gethostbyname_ex(...)  的返回值一个元组（tuple）。这个元组包含三个元素，
        local_ips.append(ip)                                                                       #  结构是这样的：('主机名', ['别名列表'], ['IP地址列表'])
                                                                              # **第一个第一个元素 ([0]): 官方主机名（字符串）。
    local_ips.sort(reverse = True)  #对列表进行降序排序。这通常是为了让那些看起来更“重要”或更常用的IP（比如 192. 开头的局域网IP）排在前面，而 127.0.0.1 排在后面。这是一个编程习惯，不是必须的，但能让结果更友好。
    return local_ips    
                                                                               # 第二个元素 ([1]): 这个主机的别名列表（一个字符串列表），通常是空的。

                                                                               # 第三个元素 ([2]): **所有与该主机名关联的所有与该主机名关联的IP地址（一个字符串列表）。这正是我们想要的！
        
        
        

    

